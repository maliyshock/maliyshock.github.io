{"version":3,"sources":["constants.tsx","helper.tsx","components/cell.tsx","components/chunk.tsx","components/map.tsx","App.tsx","serviceWorker.js","index.tsx"],"names":["CHUNK_SIZE_X","CHUNK_SIZE_Y","round","value","exp","Math","isNaN","NaN","toString","split","convertToAbsolute","chunkMultiplier","size","getTheAbsoluteStuff","x","y","xChunkNumber","yChunkNumber","a_x","a_y","absCoordinates","concat","generateChunks","map","mapRows","_","chunk","saveChunks","mr","length","r","row","incrementator","col","newPart","slice","isEmpty","suspiciousnessLevel","push","hasNumber","myString","test","extractNumberFromString","keyToFind","match","Number","Cell","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","highlited","socket","rowKey","itemKey","send","e","preventDefault","persist","setState","string","hint","_this2","counter","item","buttonModifier","getColor","title","undefined","isMine","isSafe","react_default","a","createElement","className","onContextMenu","setMine","onClick","cellHandler","key","React","Component","Chunk","isActive","renderChunk","chunkMap","items","colMultiplier","rowMultiplier","itemAbsCoords","itemCoords","mines","safe","cell","Map","hintsAreHidden","amountOfChunkRows","chunks","keys","rowName","rowIndex","chunkName","chunkIndex","components_chunk","initialState","WebSocket","rows","cols","cells","xChunksAmount","yChunksAmount","currentXStartPoint","currentYStartPoint","endOfMapIsReached","currentChunkIs","playing","decisionMade","notShureChunks","operationStatus","level","lose","win","winRate","App","objectSpread","_this3","data","callback","result","i","neighborsArray","emptyCellsCounter","minesAround","some","currentChunkRow","currentChunkCol","prevState","update","defineProperty","$set","_getTheAbsoluteStuff","colName","newState","_getTheAbsoluteStuff2","coordinates","newValue","prediction","suspiciousnessOfItem","setSuspiciousness","rowIdentifier","colIdentifier","newY","newX","coordinatesToCheck","neighbor","areThereNeighbor","_this$whatDoWeHaveHer","whatDoWeHaveHere","loopThroughNeighbors","bind","setSafe","analyzeOfNeighbors","safeObj","name","objectArg","firstKey","firstSaved","updatedSafe","objectWithoutProperties","_toPropertyKey","smallestPredictionCoords","_this4","forOwn","errasePredictions","_this5","onopen","document","addEventListener","keyCode","onmessage","_parseData","splitedData","parseData","newChunks","predictionResult","emptyRows","emptyCells","rowPosition","isChunkHasNumbers","loop1","parseInt","makePrediction","makeDecision","goToTheNextChunk","openSafeCell","_this6","hintsVisibility","levelRiseUpDisabled","levelReduceDisabled","disabled","reduceDifficulty","riseUpDifficulty","startButtonHandler","components_map","Boolean","window","location","hostname","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7720d8ab.chunk.js","sourcesContent":["export const CHUNK_SIZE_X = 10;\nexport const CHUNK_SIZE_Y = 10;","import _ from 'lodash';\nimport { CHUNK_SIZE_X, CHUNK_SIZE_Y } from './constants';\n\nimport { chunks } from './interfaces/interfaces';\n\nexport function round( value: number|string, exp: number) {\n    // If the exp is undefined or zero...\n    if (typeof exp === 'undefined' || +exp === 0) {\n        // @ts-ignore\n        return Math.round(value);\n    }\n    value = +value;\n    exp = +exp;\n    // If the value is not a number or the exp is not an integer...\n    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {\n        return NaN;\n    }\n    // Shift\n    // @ts-ignore\n    value = value.toString().split('e');\n    // @ts-ignore\n    value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));\n    // Shift back\n    // @ts-ignore\n    value = value.toString().split('e');\n    // @ts-ignore\n    return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));\n}\n\n\nexport function convertToAbsolute(value: number, chunkMultiplier: number, size: number) {\n    return value + ( chunkMultiplier * size );\n}\n\nexport function getTheAbsoluteStuff(x: number, y: number, xChunkNumber: number, yChunkNumber: number) {\n    let a_x = convertToAbsolute( x, xChunkNumber, CHUNK_SIZE_X );\n    let a_y = convertToAbsolute( y, yChunkNumber, CHUNK_SIZE_Y );\n    let absCoordinates = `x${a_x}y${a_y}`;\n\n    return { a_x, a_y, absCoordinates }\n}\n\n\nexport function generateChunkName(r: number, c: number) {\n    return `chunk_r${r}_c${c}`\n}\n\nexport function generateChunks(map: string[]):chunks {\n    let mapRows = _.chunk(map, CHUNK_SIZE_Y); // 2\n    // this.setState({amountOfChunkRows: mapRows.length});\n    let saveChunks: chunks = {};\n\n    for (let mr = 0; mr < mapRows.length;  mr++) {\n        for (let r = 0; r < mapRows[mr].length;  r++) {\n            let row =  mapRows[mr][r];\n            let incrementator = 0;\n\n\n            for (let col = 0; col < row.length; col = col + CHUNK_SIZE_X) {\n                // let chunkName = generateChunkName(mr, col);\n                let newPart = row.slice( col, col + CHUNK_SIZE_X );\n\n                if( _.isEmpty( saveChunks[`row_${mr}`] ) ) {\n                    saveChunks[`row_${mr}`] = {};\n                }\n\n                if( _.isEmpty( saveChunks[`row_${mr}`][`col_${incrementator}`] ) ) {\n                    saveChunks[`row_${mr}`][`col_${incrementator}`] = { map: [],suspiciousnessLevel: {} };\n                }\n\n                saveChunks[`row_${mr}`][`col_${incrementator}`].map.push(newPart);\n                incrementator++;\n            }\n        }\n    }\n\n    return saveChunks;\n}\n\nexport function hasNumber(myString: string) {\n    return /^(?=.*\\d)(?=.*[1-9]).{1,10}$/.test(myString);\n}\n\n\nexport function parseData(e: MessageEvent) {\n    let data: string = e.data;\n    let splitedData: string[] = _.split(data, '\\n');\n    let operationStatus: string = splitedData[0];\n    let map: string[] = [];\n    let rows: number = 0;\n    let cols: number = 0;\n\n    if (splitedData.length > 1) {\n        map = _.slice(splitedData, 1, splitedData.length - 1);\n        rows = map.length;\n        cols = map[0].length;\n    }\n\n    return {map, operationStatus, rows, cols};\n}\n\nexport function removeProp(name: string, objectArg: { [key: string]: { x: number, y: number } } ) {\n    const { [name]: val, ...remaning } = objectArg;\n    return remaning;\n}\n\nexport function extractNumberFromString(keyToFind: string): number {\n    // @ts-ignore\n    return keyToFind.match(/\\d+/g).map(Number)[0];\n}","import React, {MouseEvent} from 'react';\n\nimport { round } from './../helper';\n\nexport interface cellState {\n    highlited: boolean\n}\n\nexport interface cellProps {\n    socket: WebSocket,\n    item: string,\n    itemKey: number,\n    row: string,\n    rowKey: number,\n    suspiciousnessLevel: { x: number, y: number, value: number, counter: number } | undefined,\n    isMine: boolean,\n    isSafe: boolean,\n}\n\nclass Cell extends React.Component<cellProps, cellState> {\n    constructor(props:any) {\n        super(props);\n        this.state = {\n            highlited: false\n        }\n    }\n\n    cellHandler(socket:WebSocket, rowKey:number, itemKey:number){\n        this.props.socket.send(`open ${itemKey} ${rowKey}`);\n    }\n\n    setMine(e:MouseEvent) {\n        e.preventDefault();\n        e.persist();\n\n        this.setState({\n            highlited: !this.state.highlited\n        });\n        return false;\n    }\n\n    getColor(string:string) {\n        switch (string) {\n            case '□':\n                return 'gray';\n\n            case '0':\n                return 'gray';\n\n            case '1':\n                return 'blue';\n\n            case '2':\n                return 'green';\n\n            case '3':\n                return 'red';\n\n            default:\n                break;\n        }\n    }\n\n    componentDidMount() {\n\n    }\n\n    render() {\n        let suspiciousnessLevel: number ;\n        let counter: number = 0;\n        let item = this.props.item;\n        let itemKey = this.props.itemKey;\n        let rowKey = this.props.rowKey;\n        let buttonModifier = (item !== '□') ? `button--bg-gray button--color-${this.getColor(item)}`: '';\n        let title = (item === '□' || item === '0') ?  '' : item;\n        let hint: string;\n\n        if( this.props.suspiciousnessLevel !== undefined ) {\n            counter = this.props.suspiciousnessLevel.counter;\n            suspiciousnessLevel = this.props.suspiciousnessLevel.value;\n\n            hint = (item === '□') ? `${ round(suspiciousnessLevel * 100, -2 )}% \\n(${counter})` : '';\n\n        } else {\n            hint = ''\n        }\n\n        if( this.props.isMine) {\n            buttonModifier += ' mine';\n        }\n        if( this.props.isSafe) {\n            buttonModifier += ' safe';\n        }\n\n        if(this.state.highlited) {\n            buttonModifier += ' pseudo-mine';\n        }\n\n        return <li className='map__cell'\n                   onContextMenu={(e) => this.setMine(e)}\n                   onClick={() => this.cellHandler(this.props.socket, rowKey, itemKey)}\n                   key={itemKey}>\n            <button title={title} className={`map__button button ${buttonModifier}`}>{ (item === '□') ? '' : item}</button>\n            <div className={`map__cell-hint map__cell-hint--${counter}`}>{hint}</div>\n        </li>\n    }\n}\n\nexport default Cell;","import React from 'react';\nimport Cell from './cell'\nimport { convertToAbsolute } from './../helper';\nimport { CHUNK_SIZE_X, CHUNK_SIZE_Y } from './../constants';\n\nexport interface chunkProps {\n    chunkMap: string[],\n    socket: WebSocket,\n    rowMultiplier: number,\n    colMultiplier: number,\n    mines: { [key: string]: { x: number, y: number } },\n    safe: { [key: string]: { x: number, y: number } },\n    suspiciousnessLevel: {\n        [coordinates: string]: { x: number, y: number, value: number, counter: number }\n    },\n    isActive: boolean\n}\n\nexport interface chunkState {\n\n}\n\nclass Chunk extends React.Component<chunkProps, chunkState>{\n    constructor(props: any) {\n        super(props);\n        this.state = {\n\n        }\n    }\n\n    render() {\n        let isActive = (this.props.isActive) ? ' active' : '';\n\n        let renderChunk = this.props.chunkMap.map((row:string, rowKey) => {\n            let items = row.split('').map((item: string, itemKey) => {\n                let a_x = convertToAbsolute(itemKey, this.props.colMultiplier, CHUNK_SIZE_X);\n                let a_y = convertToAbsolute(rowKey, this.props.rowMultiplier, CHUNK_SIZE_Y);\n                let isMine: boolean;\n                let isSafe: boolean;\n                let itemAbsCoords = `x${a_x}y${a_y}`;\n                let itemCoords = `x${itemKey}y${rowKey}`;\n\n                isMine = (itemAbsCoords in this.props.mines);\n                isSafe = (itemAbsCoords in this.props.safe);\n\n                let suspiciousnessLevel = (this.props.suspiciousnessLevel !== undefined) ? this.props.suspiciousnessLevel[itemCoords] : undefined\n\n                return <Cell\n                    suspiciousnessLevel={suspiciousnessLevel}\n                    socket={this.props.socket}\n                    item={item}\n                    itemKey={itemKey}\n                    key={itemKey}\n                    row={row}\n                    rowKey={rowKey}\n                    isMine={isMine}\n                    isSafe={isSafe}\n                />\n            });\n\n            return <ul className='chunk__row' key={rowKey}>{items}</ul>;\n        });\n\n        return (\n            <ul className={`map__chunk ${isActive}`}>\n                <li className='map chunk'>\n                    { renderChunk }\n                </li>\n            </ul>\n        )\n    }\n}\n\nexport default Chunk;","import React from 'react';\nimport Chunk from './chunk'\n// import { CHUNK_SIZE_X, CHUNK_SIZE_Y } from './../constants';\nimport _ from 'lodash';\n\nimport { chunks } from './../interfaces/interfaces';\n\n\nexport interface mapState {\n    hintsAreHidden: boolean,\n    amountOfChunkRows: number\n}\n\nexport interface mapProps {\n    map: string[] | undefined,\n    socket: WebSocket,\n    chunks: chunks,\n    mines: { [key: string]: { x: number, y: number } },\n    safe: { [key: string]: { x: number, y: number } },\n    xChunkNumber: number,\n    yChunkNumber: number\n}\n\nclass Map extends React.Component<mapProps, mapState> {\n    constructor(props: any) {\n        super(props);\n        this.state = {\n            hintsAreHidden: false,\n            amountOfChunkRows: 0\n        }\n    }\n\n\n    componentDidMount() {\n\n    }\n\n    render() {\n        return(\n            <ul className='map__list'>\n                {\n                    ( !_.isEmpty(this.props.chunks) ) ?\n                    Object.keys(this.props.chunks).map( (rowName, rowIndex) => {\n                        return (\n                            <li className='map__row' key={rowName}>\n                                {\n                                    Object.keys( this.props.chunks[rowName] ).map( (chunkName, chunkIndex) => {\n                                        let isActive = (chunkIndex === this.props.xChunkNumber && rowIndex === this.props.yChunkNumber);\n\n                                        return <Chunk\n                                            key={rowName+chunkName}\n                                            socket={this.props.socket}\n                                            chunkMap={this.props.chunks[rowName][chunkName]['map']}\n                                            suspiciousnessLevel={this.props.chunks[rowName][chunkName]['suspiciousnessLevel']}\n                                            rowMultiplier={rowIndex}\n                                            colMultiplier={chunkIndex}\n                                            mines={this.props.mines}\n                                            safe={this.props.safe}\n                                            isActive={isActive}\n                                        />\n                                    })\n                                }\n                            </li>\n                        )\n\n                    })\n                        : ''\n                }\n            </ul>\n        );\n    }\n}\n\nexport default Map;","import React from 'react';\nimport Map from './components/map'\nimport './App.css';\nimport _ from 'lodash';\nimport update from 'immutability-helper';\n\nimport { CHUNK_SIZE_X, CHUNK_SIZE_Y } from './constants';\nimport { round, convertToAbsolute, generateChunks, hasNumber, parseData, removeProp, extractNumberFromString, getTheAbsoluteStuff } from './helper';\nimport { gameState, chunk, neighbor } from './interfaces/interfaces';\n\nlet initialState = {\n    socket: new WebSocket('wss://hometask.eg1236.com/game1/'),\n    map: undefined,\n    rows: undefined,\n    cols: undefined,\n    cells: undefined,\n\n    xChunksAmount: 0,\n    yChunksAmount: 0,\n    xChunkNumber: 0,\n    yChunkNumber: 0,\n    currentXStartPoint: 0,\n    currentYStartPoint: 0,\n    endOfMapIsReached: false,\n\n    currentChunkIs: [],\n    chunks: {},\n    mines: {},\n    safe: {},\n\n    playing: true,\n\n    decisionMade: false,\n\n    notShureChunks: {},\n\n    operationStatus: undefined,\n    hintsAreHidden: true,\n    title: 'Lets Rock',\n\n    level: 2,\n    lose: 0,\n    win: 0,\n    winRate: undefined\n};\n\nclass App extends React.Component<{}, gameState> {\n    constructor(props: any) {\n        super(props);\n\n        this.state = initialState;\n\n        // help      - returns valid commands\n        // new L     - starts new session, L=1|2|3|4\n        // map       - returns the current map\n        // open X Y  - opens cell at X,Y coordinates\n\n        // on connection send comand to begin game\n    }\n\n    startButtonHandler(socket: WebSocket) {\n        socket.send(`new ${this.state.level}`);\n    }\n\n    helpButtonHandler(socket: WebSocket) {\n        socket.send('help');\n    }\n\n    reduceDifficulty() {\n        this.setState( state => {\n            return (this.state.level > 1) ? { ...state, level: state.level - 1} : state;\n        })\n    }\n\n    riseUpDifficulty() {\n        this.setState( state => {\n            return (this.state.level < 4) ? {...state, level: state.level + 1} : state;\n        })\n    }\n\n    // loop through the list of neighbor coordinates and do callback function\n    loopThroughNeighbors( data: {\n        neighborsArray: neighbor[],\n        value: number,\n        emptyCellsCounter: number,\n        minesAround: number\n    }, callback: ( x: number, y: number, chunk: chunk, value: number, emptyCellsCounter: number, minesAround: number ) => boolean ) {\n        let result:boolean[] = [];\n        for (let i = 0; i < data.neighborsArray.length; i++) {\n            // get the coords from the iterated object\n            let x: number = data.neighborsArray[i]['x'];\n            let y: number = data.neighborsArray[i]['y'];\n            let chunk = data.neighborsArray[i].chunk;\n\n            // in case callback returns false break the cycle\n            // not the break cycle if we do not have any new information\n            // or we making analysis\n            // new information will be mine or safe point not in the array of mines or safe points\n            result.push( callback( x, y, chunk, data.value, data.emptyCellsCounter, data.minesAround ) );\n        }\n\n        // can we continue the loop above or not\n        return !result.some( item => item === false);\n    }\n\n    // checks if current chunk in state has numbers inside\n    // if yes returns position\n    isChunkHasNumbers() {\n        // start from the first tow\n        let length = this.state.currentChunkIs.length;\n\n        for (let i = 0; i < length; i++) {\n            if ( hasNumber( this.state.currentChunkIs[i] ) ) {\n                return i;\n            }\n        }\n        return false\n    }\n\n    errasePredictions(currentChunkRow: string, currentChunkCol: string) {\n        this.setState(prevState => {\n            return update(prevState, {\n                chunks: {\n                    [currentChunkRow]: {\n                        [currentChunkCol]: {\n                            suspiciousnessLevel: { $set: {} }\n                        }\n                    }\n                }\n            })\n        });\n    }\n\n    /* TODO:\n     * how to avoid unnecessary parameters?\n     */\n    setMine( x: number, y: number, chunk: chunk,  value?: number, emptyCellsCounter?: number, minesAround?: number) {\n        let row = chunk.rowName;\n        let col = chunk.colName;\n\n        let { a_x, a_y, absCoordinates } = getTheAbsoluteStuff(x, y, extractNumberFromString(col), extractNumberFromString(row) );\n\n        if( !(absCoordinates in this.state.mines) ) {\n            let newState = update (\n                this.state, {\n                    mines: {\n                        [absCoordinates]: { $set: { x: a_x, y: a_y } }\n                    },\n                    endOfMapIsReached: { $set: false}\n                });\n\n            this.setState(newState);\n\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    setSafe( x: number, y: number, chunk: chunk,  value?: number, emptyCellsCounter?: number, minesAround?: number) {\n        let row = chunk.rowName;\n        let col = chunk.colName;\n\n        let { a_x, a_y, absCoordinates } = getTheAbsoluteStuff(x, y, extractNumberFromString(col), extractNumberFromString(row) );\n\n        if ( this.state.mines !== undefined && !( absCoordinates in this.state.mines ) ) {\n            // update safe cells\n            let newState = update (\n                this.state, {\n                    safe: {\n                        [absCoordinates]: { $set: { x: a_x, y: a_y } }\n                    },\n                    endOfMapIsReached: { $set: false}\n                });\n\n            this.setState(newState);\n\n            return false;\n        } else {\n            return true\n        }\n    }\n\n    setSuspiciousness(row: string, col: string, coordinates: string, newValue: number, counter: number, x: number, y: number ) {\n        this.setState(prevState => {\n            return update(prevState, {\n                chunks: {\n                    [row]: {\n                        [col]: {\n                            suspiciousnessLevel: {\n                                [coordinates]: {\n                                    $set: { value: newValue, counter, x: x, y: y }\n                                }\n                            }\n                        }\n                    }\n                }\n            })\n        });\n    }\n\n    analyzeOfNeighbors( x: number, y: number, chunk: chunk, value: number, emptyCellsCounter: number, minesAround: number ) {\n        let row = chunk.rowName;\n        let col = chunk.colName;\n\n        // make prediction for all near empty cells\n        let prediction: number = value / (emptyCellsCounter - minesAround) ;\n        let newValue: number;\n        let counter: number; // amount of intersections\n        let coordinates = `x${x}y${y}`;\n\n        // in case of having the different chunk, we can recalculate current yChunkNumber and xChunkNumber\n        let { absCoordinates } = getTheAbsoluteStuff(x, y, extractNumberFromString(col), extractNumberFromString(row) );\n\n        let suspiciousnessOfItem = ( this.state.chunks[row][col] !== undefined ) ? this.state.chunks[row][col].suspiciousnessLevel[coordinates] : undefined;\n\n        if( !(absCoordinates in this.state.mines) ) {\n                // if prediction level of coordinates exist\n            if (suspiciousnessOfItem !== undefined) {\n                newValue =  round((suspiciousnessOfItem['value'] + prediction)/2, -2) ;\n                // newValue =  round( 1 - (1 - suspiciousnessOfItem['value']) * (1 - prediction ), -2 );\n                counter = suspiciousnessOfItem['counter'] + 1 ;\n            } else {\n                newValue = round( prediction, -2);\n                counter = 1;\n            }\n\n            this.setSuspiciousness(row, col, coordinates, newValue, counter, x, y)\n        }\n        return true;\n    }\n\n    areThereNeighbor(x: number, y: number) {\n        let rowIdentifier = this.state.yChunkNumber;\n        let colIdentifier = this.state.xChunkNumber;\n        let colName = 'col_';\n        let rowName = 'row_';\n        let newY = y;\n        let newX = x;\n\n        // check if this coordinates of current chunk\n        if ( this.state.currentChunkIs[y] !== undefined && this.state.currentChunkIs[y][x] !== undefined ) {\n            rowName += `${this.state.yChunkNumber}`;\n            colName += `${this.state.xChunkNumber}`;\n\n            return {\n                x: x,\n                y: y,\n                value: this.state.currentChunkIs[y][x],\n                chunk: {\n                    rowName: rowName,\n                    colName: colName\n                }\n            };\n        } else {\n            // if not, check what chunk belong those coordinates\n            // convert coordinates and set new col and row names according to new chunk\n\n            if( y >= CHUNK_SIZE_Y) {\n                rowIdentifier = rowIdentifier + 1;\n                newY = y - CHUNK_SIZE_Y;\n            } else if (y < 0) {\n                rowIdentifier = rowIdentifier - 1;\n                newY = y + CHUNK_SIZE_Y;\n            }\n\n            rowName += `${rowIdentifier}`;\n\n            if( !(rowName in this.state.chunks) ) {\n                return undefined;\n            }\n\n            if( x >= CHUNK_SIZE_X) {\n                colIdentifier = colIdentifier + 1;\n                newX = x - CHUNK_SIZE_X;\n            } else if (x < 0) {\n                colIdentifier = colIdentifier - 1;\n                newX = x + CHUNK_SIZE_X;\n            }\n            colName += `${colIdentifier}`;\n\n\n            if( !(colName in this.state.chunks[rowName]) ) {\n                return undefined;\n            }\n\n            let theChunk = this.state.chunks[rowName][colName].map;\n            return {\n                x: newX,\n                y: newY,\n                value: theChunk[newY][newX],\n                chunk: {\n                    rowName: rowName,\n                    colName: colName\n                }\n            };\n        }\n    }\n\n    // relative coordinates to current chunk is\n    whatDoWeHaveHere(x: number, y: number) {\n        let emptyCellsCounter: number = 0;\n        let neighborsArray = [];\n        let minesAround = 0;\n\n        // list of poteintial cells around\n        let coordinatesToCheck = [\n            { x: x - 1, y: y - 1 },\n            { x: x,     y: y - 1 },\n            { x: x + 1, y: y - 1 },\n            { x: x - 1, y: y },\n            { x: x + 1, y: y },\n            { x: x - 1, y: y + 1 },\n            { x: x,     y: y + 1 },\n            { x: x + 1, y: y + 1 },\n        ];\n\n        for (let i = 0; i < coordinatesToCheck.length; i++) {\n            // go through list and check if cell exist on the map\n            // if it is, save it coords and value to the variable\n            let neighbor: neighbor | undefined = this.areThereNeighbor(coordinatesToCheck[i]['x'], coordinatesToCheck[i]['y']);\n            // if this neighbor exist on the map\n            if ( neighbor !== undefined && neighbor.value === '□' ) {\n                // @ts-ignore\n                let { absCoordinates } = getTheAbsoluteStuff(neighbor.x, neighbor.y, extractNumberFromString(neighbor.chunk.colName), extractNumberFromString(neighbor.chunk.rowName) )\n\n                // do we have mines around this area\n                if (absCoordinates in this.state.mines) {\n                    minesAround++;\n                }\n                emptyCellsCounter++;\n                neighborsArray.push(neighbor);\n            }\n        }\n\n        return { minesAround, emptyCellsCounter, neighborsArray }\n    }\n\n    makePrediction(y: number, x: number, value: number): boolean {\n        let result = true;\n        if (this.state.map !== undefined) {\n            let { minesAround, emptyCellsCounter, neighborsArray } = this.whatDoWeHaveHere(x, y);\n\n            // if there are neighbors\n            if (neighborsArray.length > 0 && neighborsArray.length > minesAround) {\n                // in case there are only options equals to amount of mines\n                // save those coordinates as 100% mines\n                // count amount of 100% mines around\n                if (value === emptyCellsCounter) {\n                    // minesAround = value;\n                    result = this.loopThroughNeighbors({ neighborsArray, value, emptyCellsCounter, minesAround}, this.setMine.bind(this) );\n                } else if ((value === minesAround) && (emptyCellsCounter > minesAround)) {\n                    // in case if we know how many mines around and the amount of empty cells more than mines around number\n                    // safe cells = neighbors - mines\n                    result = this.loopThroughNeighbors( { neighborsArray, value, emptyCellsCounter, minesAround}, this.setSafe.bind(this) );\n                } else {\n                    // in case we do not have information about mines around make some hypothesis and predictions\n                    // save prediction level for accessible neighbors\n                    result = this.loopThroughNeighbors( { neighborsArray, value, emptyCellsCounter, minesAround }, this.analyzeOfNeighbors.bind(this) );\n                }\n            }\n        }\n        return result;\n    }\n\n    openSafeCell() {\n        let safeObj = this.state.safe;\n\n        if (safeObj !== undefined && !( _.isEmpty(safeObj) )) {\n            // pick up first object element\n            let firstKey = Object.keys(safeObj)[0];\n            let firstSaved = safeObj[firstKey];\n\n            // save it coords\n            let x = firstSaved.x;\n            let y = firstSaved.y;\n\n            // remove it from the state\n            let updatedSafe = removeProp(firstKey, this.state.safe);\n            this.setState({safe: updatedSafe});\n\n            // open coords\n            this.state.socket.send(`open ${x} ${y}`);\n        }\n        else {\n            return false\n        }\n    }\n\n    goToTheNextChunk() {\n        // go to the next chunk if it is possible\n        if( this.state.xChunkNumber < this.state.xChunksAmount ) {\n            this.setState( {\n                xChunkNumber: this.state.xChunkNumber + 1,\n                currentChunkIs: this.state.chunks[`row_${this.state.yChunkNumber}`][`col_${this.state.xChunkNumber + 1}`].map\n            })\n        }\n        else if ( this.state.yChunkNumber < this.state.yChunksAmount ) {\n            this.setState( {\n                yChunkNumber: this.state.yChunkNumber + 1,\n                xChunkNumber: 0,\n                currentChunkIs: this.state.chunks[`row_${this.state.yChunkNumber + 1}`][`col_0`].map\n            })\n        }\n    }\n\n    // picked smallest avaliable prediction to send\n    makeDecision(currentChunkRow: string, currentChunkCol: string):boolean {\n        let smallestPredictionCoords: { value: number, counter: number, x: number, y: number } | undefined;\n        // if there are some suspiciousness cells\n        if (!_.isEmpty( this.state.chunks[currentChunkRow][currentChunkCol].suspiciousnessLevel) ) {\n            _.forOwn(this.state.chunks[currentChunkRow][currentChunkCol].suspiciousnessLevel, (value, key) => {\n                // if there is no saved smallestPredictionCoords\n                if (smallestPredictionCoords === undefined ||\n                    ( ( value.value <= smallestPredictionCoords.value ) && !(`x${value.x}y${value.y}` in this.state.mines )) ) {\n                    // if we found smaller prediction than previous one\n                    smallestPredictionCoords = value;\n                }\n            });\n\n            // pick up samllest decision\n            if ( smallestPredictionCoords !== undefined &&\n                // smallestPredictionCoords.value < 100 &&\n                    !( `x${smallestPredictionCoords.x}y${smallestPredictionCoords.y}` in this.state.mines )\n                ) {\n\n                let a_x = convertToAbsolute(smallestPredictionCoords.x, this.state.xChunkNumber, CHUNK_SIZE_X);\n                let a_y = convertToAbsolute(smallestPredictionCoords.y, this.state.yChunkNumber, CHUNK_SIZE_Y);\n\n                // errase previous predictions for this chunk\n                this.errasePredictions(currentChunkRow, currentChunkCol);\n\n                this.state.socket.send(`open ${a_x} ${a_y}`);\n                return true;\n            }\n            // there is no predictions save coordinates of this one item, and go to the next chunk\n            else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    componentDidMount() {\n        this.state.socket.onopen = () => {};\n\n        document.addEventListener('keydown', (e) => {\n            // tab key\n            if (e.keyCode === 9) {\n                e.preventDefault();\n                this.setState(prevState => ({\n                    hintsAreHidden: !prevState.hintsAreHidden\n                }));\n            }\n        });\n\n        this.state.socket.onmessage = (e: MessageEvent) => {\n            // each time as we got message we save the new data\n            let {map, operationStatus, cols, rows} = parseData(e);\n\n            // update the state with new data\n            this.setState({\n                map: map,\n                operationStatus: operationStatus,\n                cols: cols,\n                rows: rows,\n                cells: cols * rows,\n\n                decisionMade: false,\n\n                xChunksAmount: ( cols / CHUNK_SIZE_X ) - 1,\n                yChunksAmount: ( rows / CHUNK_SIZE_Y ) - 1\n            });\n\n            // if map exist and we are ready to play\n            if (map !== undefined && map.length > 0 && operationStatus !== 'open: You lose' && operationStatus !== 'open: You win' && this.state.playing) {\n                let newChunks = generateChunks( map );\n                let currentChunkRow = `row_${this.state.yChunkNumber}`;\n                let currentChunkCol = `col_${this.state.xChunkNumber}`;\n\n                this.setState({\n                    chunks: newChunks ,\n                    currentChunkIs: newChunks[currentChunkRow][currentChunkCol].map\n                });\n\n                let predictionResult = true;\n                let emptyRows = 0;\n                let emptyCells = 0;\n\n                // returns row number of current chunk if the row has numbers inside\n                let rowPosition = this.isChunkHasNumbers();\n\n\n                // if we have any 100% safety cells - open oen\n                if (!_.isEmpty(this.state.safe)) {\n                    this.openSafeCell();\n                } else {\n                    // if we have row with number\n                    if (rowPosition !== false) {\n                        // loop through piece(chunk) copied and saved to the state from the global map\n                        loop1:\n                            for (let y: number = rowPosition; y < this.state.currentChunkIs.length; y++) {\n                                // row position is start point, but we could have empty rows after\n                                if ( hasNumber( this.state.currentChunkIs[y] ) ) {\n                                    for (let x = 0; x < this.state.currentChunkIs[y].length; x++) {\n                                        // does it have any numbers inside\n\n                                        let a_x = convertToAbsolute(x, this.state.xChunkNumber, CHUNK_SIZE_X);\n                                        let a_y = convertToAbsolute(y, this.state.yChunkNumber, CHUNK_SIZE_Y);\n\n                                        let item = map[a_y][a_x];\n                                        // if this is a number with value > 0\n                                        if (item !== '□' && ( _.parseInt(item) > 0 ) ) {\n                                            //returns false, when set mine or safe cells\n                                            predictionResult = this.makePrediction(y, x, _.parseInt(item));\n\n                                            // if we found mine or safe cells we will get false,\n                                            if( predictionResult === false ) {\n\n                                                // errase previous predictions for this chunk\n                                                this.errasePredictions(currentChunkRow, currentChunkCol);\n                                                //  break the current cycle\n                                                break loop1;\n                                            }\n                                        } else if( item === '□' ) {\n                                            if( !(`x${a_x}y${a_y}` in this.state.mines) ) {\n                                                emptyCells++\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    emptyRows++;\n                                }\n                            }\n                    }\n\n                    if( predictionResult ) {\n                        // if we reached the end of the map and we do not have any choice except to make decisions\n                        if( this.state.xChunksAmount === this.state.xChunkNumber && this.state.yChunksAmount === this.state.yChunkNumber && !this.state.endOfMapIsReached) {\n                            this.setState( {  xChunkNumber: 0, yChunkNumber: 0, endOfMapIsReached: true } );\n                        }\n                        // if there are some empty avaliable to choose cells - try to make decision\n                        else if( (emptyCells > 0 || emptyRows > 0) && this.state.endOfMapIsReached) {\n                            // if there no any avaliable predictions < 100 we can not make decision\n\n                            this.makeDecision(currentChunkRow, currentChunkCol);\n                            this.setState( { endOfMapIsReached: false, decisionMade: true } );\n                        } else {\n                            this.goToTheNextChunk();\n                        }\n                    }\n\n                    if( !this.state.decisionMade ) {\n                        this.state.socket.send('map');\n                    }\n                }\n\n\n            } else if(map !== undefined && map.length > 0) {\n                let newChunks = generateChunks( map );\n                let currentChunkRow = `row_${this.state.yChunkNumber}`;\n                let currentChunkCol = `col_${this.state.xChunkNumber}`;\n\n                this.setState({\n                    chunks: newChunks ,\n                    currentChunkIs: newChunks[currentChunkRow][currentChunkCol].map\n                });\n            }\n\n            switch (operationStatus) {\n                case 'new: OK':\n                    this.setState(initialState);\n\n                    // get data\n                    this.state.socket.send('open 0 0');\n                    break;\n\n                case 'map:':\n                    break;\n\n                case 'help:':\n                    break;\n\n                case 'open: You lose':\n                    this.setState({\n                        title: 'You lose',\n                        lose: this.state.lose + 1,\n                        winRate: ( this.state.win / (this.state.lose + 1) ) * 100,\n                        chunks: {},\n                        playing: false\n\n                    });\n                    // this.state.socket.send('map');\n                    this.state.socket.send(`new ${this.state.level}`);\n                    break;\n\n                case 'open: You win':\n                    this.setState({\n                        title: 'You Win',\n                        win: this.state.win + 1,\n                        winRate: ( (this.state.win + 1) / this.state.lose ) * 100,\n                        playing: false\n                    });\n\n                    break;\n\n                case 'open: Out of bounds':\n                    break;\n\n                case 'open: OK':\n                    this.state.socket.send('map');\n                    break;\n\n                default:\n                    break;\n            }\n        };\n    }\n\n\n    render() {\n        let hintsVisibility = (this.state.hintsAreHidden) ? 'map--hints-are-visible' : '';\n\n        let levelRiseUpDisabled = (this.state.level === 4);\n        let levelReduceDisabled = this.state.level === 1;\n\n        return (\n            <div className='app'>\n                <div className=\"app__box\">\n                    <div className=\"difficulty\">\n                        <span className=\"h2 difficulty__title\">Choose difficulty:</span>\n\n                        <span className=\"difficulty__inner\">\n                            <button className=\"button arrow arrow--shape-up\" disabled={levelReduceDisabled} onClick={() => this.reduceDifficulty()}>–</button>\n                            <span className=\"h2\">{this.state.level}</span>\n                            <button className=\"button arrow arrow--shape-up\" disabled={levelRiseUpDisabled} onClick={() => this.riseUpDifficulty()}>+</button>\n                        </span>\n                    </div>\n                </div>\n\n                <div className='app__buttons'>\n                    <button className='button' onClick={() => this.startButtonHandler(this.state.socket)}>Start New Game</button>\n                </div>\n\n                <div className=\"app__box\">\n                    <h2>{this.state.title}: {}</h2>\n                    { (this.state.map !== undefined) ?\n                        <Map chunks={this.state.chunks}\n                             map={this.state.map}\n                             mines={this.state.mines}\n                             safe={this.state.safe}\n                             socket={this.state.socket}\n                             xChunkNumber={this.state.xChunkNumber}\n                             yChunkNumber={this.state.yChunkNumber}\n                        /> : ''}\n                </div>\n\n                <div className={`app__map map ${hintsVisibility}`}></div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n"],"sourceRoot":""}